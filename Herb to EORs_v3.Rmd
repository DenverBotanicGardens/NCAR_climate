---
title: "Herbarium Bias CNHP"
author: "Michelle DePrenger-Levin"
date: "December 4, 2017"
output: html_document
---
Use Jessie's cool mapping code: "Q:\Research\All_Herbaria\KHD\Projects\exploring_herbarium_with_maps" 

Rick says don't need quotes for table or column names

MySQL query

#There are only rows in the synonym_links table when the names are synonyms, if it's not in synonym_links, it's the accepted name; taxonomic_units is the main table, if it's a synonym it's linked by synonym_links
SELECT `synonym_links`.*, `taxonomic_units`.* , `taxon_authors_lkp`.*, `geographic_div`.*
FROM `taxonomic_units` 
LEFT JOIN `synonym_links` ON `synonym_links`.`tsn` = `taxonomic_units`.`tsn` 
LEFT JOIN `taxon_authors_lkp` ON `taxon_authors_lkp`.`taxon_author_id` = `taxonomic_units`.`taxon_author_id` 
LEFT JOIN `geographic_div` ON `geographic_div`.`tsn` = `taxonomic_units`.`tsn`
WHERE `taxonomic_units`.`kingdom_id` = 3 AND `taxonomic_units`.`rank_id` = 220 AND `geographic_div`.`geographic_value` IN ('North America')



#The authorities are giving me trouble right now; can do NOT IN (0,3,9999) or whatever
SELECT `synonym_links`.*, `taxonomic_units`.* , `taxon_authors_lkp`.*
FROM `taxonomic_units` 
JOIN `synonym_links` ON `synonym_links`.`tsn` = `taxonomic_units`.`tsn` 
JOIN `taxon_authors_lkp` ON `taxon_authors_lkp`.`taxon_author_id` = `taxonomic_units`.`taxon_author_id` 
WHERE `taxonomic_units`.`kingdom_id` = 3 AND `taxonomic_units`.`rank_id` = 220 AND `taxonomic_units`.`unaccept_reason` IS NULL AND `taxonomic_units`.`taxon_author_id` NOT IN (0) AND `taxonomic_units`.`name_usage` NOT IN ('invalid') AND `taxonomic_units`.`n_usage` IN ('accepted')



#the taxon_authors_lkp.taxon_author_id isn't the tsn, it's the taxonomic_units.taxon_author_id!!!
SELECT `synonym_links`.*, `taxon_authors_lkp`.*, `taxonomic_units`.* 
FROM `taxonomic_units` 
LEFT JOIN `synonym_links` ON `synonym_links`.`tsn` = `taxonomic_units`.`tsn`
LEFT JOIN `taxon_authors_lkp` ON `taxon_authors_lkp`.`taxon_author_id` = `taxonomic_units`.`taxon_author_id` 
WHERE `taxonomic_units`.`kingdom_id` = 3 AND `taxonomic_units`.`rank_id` = 220 



SELECT `synonym_links`.*, `taxon_authors_lkp`.*, `taxonomic_units`.* 
FROM `taxonomic_units` 
LEFT JOIN `synonym_links` ON `synonym_links`.`tsn` = `taxonomic_units`.`tsn`
LEFT JOIN `taxon_authors_lkp` ON `taxon_authors_lkp`.`taxon_author_id` = `taxonomic_units`.`tsn` 
WHERE `taxonomic_units`.`kingdom_id` = 3 AND `taxonomic_units`.`rank_id` = 220 



cd /p/hackathon/Simulations/

```{r}
rm(list=ls())

# install.packages("NicheMapR") based on animal needs anyway, mechanistic
library(ggplot2)
library(rgeos)
library(sp)
library(spdep)
library(rgdal)
library(maptools)
library(raster)
library(Taxonstand)
library(RCurl)
library(taxize)
library(ggmap)

library(gganimate)


# exact match multisub
multisub <- function(pattern,replacement,x){
  result <- x
  for(i in 1:length(pattern)){
    result <- gsub(paste("^",pattern[i],"$"), paste("^",replacement[i],"$"),result)
  }
  result
}

```


```{r}
l1eor <- readShapePoly("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/L1shp")

colocounties <- readOGR(dsn="Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/Colorado/CO_Counties", layer="counties_wgs84")
colocounties.UTM <- readOGR(dsn="Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_GENERAL_non-species_files/All_General_Background_Layers/Colorado/CO_Counties", layer="counties")


plot(colocounties)

#Each polygon might be made of multiple disconnected polygons. Need to separate and label
l1G1G2 <- disaggregate(l1eor[l1eor$GRANK %in% c("G1","G2"),])
l1G1G2$PolyID <- do.call(rbind, lapply(split(l1G1G2,l1G1G2$OBJECTID),
                                       function(x){
              x$POlyID <- paste(x$EO_ID, LETTERS[seq(from=1, to= nrow(x))],sep="")
              x
              }))

#How many names in 
length(unique(l1G1G2$GNAME)) #60
write.table(unique(l1G1G2$GNAME), "clipboard", sep="\t", row.names=FALSE)


# Could take all the synonyms and names of l1G1G2 to make the list of names to pull from SEINet big list
namesg1g2 <- table(l1G1G2$GNAME)
length(namesg1g2[namesg1g2 > 0]) #60 species
g1g2names <- TPL(names(namesg1g2[namesg1g2 > 0]))
table(g1g2names$Taxonomic.status) #2 not in there, "Gutierrezia elegans" "Oonopsis sp. 1", 10 synonyms, 3 unresolved




#Are both synonyms and accepted in as GNAME?
notaccepted <- l1G1G2$GNAME[!is.na(match(l1G1G2$GNAME,
      g1g2names$Taxon[g1g2names$Taxonomic.status != "Accepted"]))]
unique(notaccepted)
g1g2names[g1g2names$Taxonomic.status != "Accepted",]

unique(l1G1G2$GNAME[grep("Boechera",l1G1G2$GNAME)])

#Are any accepted names also in the list?
l1G1G2$GNAME[l1G1G2$GNAME %in% 
               g1g2names$New.Genus[g1g2names$Taxonomic.status
                                   != "Accepted"]]

g1g2names[g1g2names$Taxonomic.status == "",] #Gutierrezia elegans; Arabis crandallii --> Boechera crandallii

g1g2names$Taxon
g1g2names$Taxon[g1g2names$Taxonomic.status == ""]
g1g2names$Taxon[g1g2names$Taxonomic.status == "Synonym"]

# All names to look for in SEINet, both the stated and the corrected by TPL
allnames <- c(g1g2names$Taxon, 
              paste(g1g2names$New.Genus,g1g2names$New.Species,sep=" "))
length(unique(allnames)) #71

```


Mo Ewing:    
     1) split all polygons (from CNHP) with ArcGIS 'explosion' tool    
     2) Copy the Feature_id field into the Parcel-num field and annotate each parcel: "a", "b" etc    
     3) Import G1G2 Seinet Vouchers into ArcMap      
     4) Create linking field: "Parcel_num"          
     5) Go through each parcel, linking the Eos by duplicating the Parcel_num.    
     6) determin the closest 'parcel' to each herabarium point using ArcMap 'near' tool Analyst Tools/Proximity/Near   *I assume to the nearest line of the polygon, nearest spot of the polygon, not to the center of the polygon          
     7) Add Map Method informaiton     
            i. "GPS" = indication that GPS was used, just GPS coordinates present    
            ii. "tr" = township/range info only recorded to township and range     
            iii. "trs" = township/Range info recorded to section, or indication that tr conversion tool used       
            iv. "trqs" = Township/Range info recorded to quarter-section       
            v. "Locality" = no verbatim data recorded, only written description recorded    
                     or "Terrain nav" (terrain navigator used)    
                     or "Nat. Geog. TOPO"    
                     or "Mapstedi"     
                     or "digital mape"     
                     or "geoLocate"     
                     or "GoogleEarth"      





# Mo Ewing's work to pull SEINet colorado specimens of G1G2 species so not sure he got all   
 also did eors <- 
```{r}
seinet_Ewingdistances <- read.csv("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/Distance Tables/Vouchers_distance.csv")

table(seinet_Ewingdistances$basisOfRec) #all PreservedSpecimen, 804
names <- names(table(seinet_Ewingdistances$scientific)) #54 names
mo_names <- TPL(names)
table(mo_names$Taxonomic.status)  
#             Accepted    Synonym Unresolved 
#         1         45          5          2 
seinet_Ewingdistances[seinet_Ewingdistances$scientific %in%
                        mo_names$Taxon[mo_names$Taxonomic.status != "Accepted"],]
```

#I must have made this one sometime, need to check again that matched all names   
I think I decided that 54 names was not all the G1/G2 so I went to get the rest one by one from SEINet instead of all Colorado specimens which then has name issues:    
coloradosps <- read.csv("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/SEINET G1 G2 Vouchers/occurrences.csv")
```{r}
seinet <- read.csv("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/SEINET G1 G2 Vouchers/seinet_colorado_with_coordinates_ALLG1G2.csv")

seinet <- seinet[seinet$genus != "",]

table(seinet$basisOfRec) #PreservedSpecimen: 1871 and HumanObservation: 4
seinet <- seinet[seinet$basisOfRecord != "HumanObservation",]
namesSEINet <- names(table(seinet$scientificName)) #93 names
SEINet_names <- TPL(namesSEINet)
table(SEINet_names$Taxonomic.status) #
#             Accepted    Synonym Unresolved 
#         2         75          9          7 
SEINet_names$scientificNameAccpt <-paste(SEINet_names$New.Genus, SEINet_names$New.Species)
write.table(SEINet_names[SEINet_names$Taxonomic.status != "Accepted",c(1,14,16,12)], "clipboard", sep="\t", row.names=FALSE)
SEINet_names[SEINet_names$Taxonomic.status != "Accepted",c(1,14,16,12)]

seinet_TPL <- merge(seinet, SEINet_names, by.x = "scientificName", by.y = "Taxon")
head(seinet_TPL) # all the information from herbarium collections and if they're accepted names or not

seinet_TPL$family <- toupper(seinet_TPL$family)

seinet_TPL[seinet_TPL$institutionCode=="USU",]
seinet_TPL$institutionCode[seinet_TPL$institutionCode=="USU"] <- "USUUB"

```

# Check when names are good or not from herbarium specimens
```{r}
namesbyyear <- table(seinet_TPL$Taxonomic.status,seinet_TPL$year)
plot(as.numeric(dimnames(namesbyyear)[[2]]),namesbyyear[2,],col="blue", type="l",
     xlab="Year",ylab="Specimens", ylim=c(0,max(namesbyyear))) #accepted
lines(as.numeric(dimnames(namesbyyear)[[2]]),namesbyyear[3,],col="green") #synonym
lines(as.numeric(dimnames(namesbyyear)[[2]]),namesbyyear[4,],col="orange") #Unresolved
lines(as.numeric(dimnames(namesbyyear)[[2]]),namesbyyear[1,],col="pink") #not in TPL
```
#Families collected over time
```{r}
familyxyear <- data.frame(table(seinet_TPL$year,seinet_TPL$family)) #now changed toupper lowercase $family has 44 levels, inconsistent capitals and lowercase..
familyxyear$Var1 <- as.numeric(as.character(familyxyear$Var1))

familyxyear[familyxyear$Freq>0,]


library(lattice)
xyplot(Freq ~ Var1|Var2, familyxyear[familyxyear$Freq>0,],
       type = c("g","p","r"),
       index = function(x,y) coef(lm(y ~ x))[1],
       xlab = "Year of Collection",
       ylab = "Number of Collections", aspect = "xy")


herbariumxyear <- data.frame(table(seinet_TPL$year,seinet_TPL$institutionCode)) 
ggplot(herbariumxyear[herbariumxyear$Freq>0,],aes(Var1, Freq, colour=Var2 ))+
  geom_point()+
  theme_bw()


unique(seinet_TPL$geodeticDatum)
seinet_TPL[seinet_TPL$geodeticDatum == "27",]
```


Would need to set eors <- seinet_Ewingdistances
```{r, eval=FALSE}
eors <- seinet_Ewingdistances
#seinetMo <- TPL(unique(seinet$scientificName))
#write.csv(seinetMo,"Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/Distance Tables/TPLseinetMo.csv")
seinetMo <- read.csv("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/Distance Tables/TPLseinetMo.csv")
sum(table(seinetMo$Taxonomic.status)) #93 names
#Mo has 2 names not in TPL, 9 synonyms, 7 unresolved
seinetMo[seinetMo$Taxonomic.status != "Accepted",]
seinet[grep("rotundifo", seinet$scientificName),]

length(table(seinet$scientificName[!is.na(seinet$decimalLatitude)])) #93 species with locaiton information


length(unique(eors$scientific)) #53 - Mo going through 1 by 1 getting SEINet data for G1G2 species ended up with 53
eors.tax <- TPL(unique(eors$scientific))
table(eors.tax$Taxonomic.status)
# 5 syn, 2 unresolved, 1 not in

eors[eors$institutio=="USU",]
eors[eors$institutio=="USUUB",]


eors$institutio[eors$institutio=="USU"] <- "USUUB"

#change all factor columns to character
i <- sapply(seinet, is.factor)
head(seinet[,i]) #recordNumber might be the only one needing to be numeric
seinet[,i] <- lapply(seinet[,i], as.character)
```

Cite MODIS data: <https://lpdaac.usgs.gov/citing_our_data>   
<https://lpdaac.usgs.gov/data_access/data_pool>  - need to get data but weeky mainenance is every wednesday until noon
```{r}


```


#Michelle DePrenger-Levin      
In ArcMap do this: <https://blogs.esri.com/esri/arcgis/2010/09/16/nearbygroup/>
repeat distance analysis in R          
"coloradosps" == SEINet collections from Colorado - downloaded 12/6/2017 from SEINet        
Only G1G2 EORs (to limit range of species)
"colonames" == TPL synonomy for all coloradosps names
```{r}
#coloradosps <- read.csv("Q:/Research/All_Projects_by_Species/aa_Shapefiles_Maps/aa_ArcMap_Projects/Link_EO_Herbarium_Records/SEINET G1 G2 Vouchers/occurrences.csv")

#save(coloradosps, file= "P:/hackathon/Simulations/coloradosps.Rda")
load("P:/hackathon/Simulations/coloradosps.Rda")

howlongrecordedby <- nchar(as.character(coloradosps$recordedBy))
head(howlongrecordedby<20)
recordedby <- unique(coloradosps$recordedBy[howlongrecordedby < 100])


table(coloradosps$basisOfRecord) # PreservedSpecimen: 566067; preservedspecimen: 55; Preserved specimen: 143; Photograph: 1; Observation: 124; Native and Naturalized Flora of; HumanObservation; many just wrong column info in this

# both of these from OBI: California Polytechnic State University
coloradosps[coloradosps$basisOfRecord == "Plants of Jefferson County Open",] #68 plus 1 more with some other typo
coloradosps[coloradosps$basisOfRecord == "Plants of Colorado",] #68 plus 1 more with some other typo

#Subset by just preserved specimens  
coloradosps$basisOfRecord <- as.character(coloradosps$basisOfRecord)
coloradosps.specimens <- coloradosps[grep("specimen",coloradosps$basisOfRecord,
                                          ignore.case=TRUE),]
table(coloradosps.specimens$basisOfRecord)

coloradosps.specimens <- coloradosps.specimens[nchar(coloradosps.specimens$basisOfRecord)<50,]
table(coloradosps.specimens$basisOfRecord)

#Now only preserved specimens
coloradosps <- coloradosps.specimens
nrow(coloradosps)


coloradosps[grep("bluffs above tributary",coloradosps$basisOfRecord) ,] #there are all messed up

g1g2names$AcceptedName <- paste(g1g2names$New.Genus,g1g2names$New.Species)
#match SEINet names to either the given or accepted names from G1/G2s
length(unique(g1g2names$Taxon))
length(unique(g1g2names$AcceptedName))
length(unique(c(g1g2names$Taxon,g1g2names$AcceptedName))) #71 


rowstomatch <- lapply(c("Taxon","AcceptedName"), function(x){
   coloradosps[,"scientificName"] %in%  g1g2names[,x]
})

#######do I need this or just take matches for coloradosps? 

#The rows to keep that match either an accepted or synonym or unresolved name for a G1G2 species
#coloradosps.specimens was intermediate to get rid of none specimen records
coloradosps.g1g2 <- unique(rbind(coloradosps[rowstomatch[[1]],],coloradosps[rowstomatch[[2]],]))
nrow(coloradosps.g1g2)
hist(as.numeric(as.character(coloradosps.g1g2$decimalLatitude)))
write.table(sort(unique(coloradosps.g1g2$scientificName)), "clipboard", sep="\t", row.names=FALSE)

setdiff(sort(unique(coloradosps.g1g2$scientificName)),sort(unique(l1G1G2$GNAME))) #species from the SEINet specimens that isn't in the names given for G1G2
setdiff(sort(unique(l1G1G2$GNAME)),sort(unique(coloradosps.g1g2$scientificName))) #the first list that's not in the second

head(g1g2names)
unique(l1G1G2$PolyID$GNAME)
plot(colocounties.UTM) #colocounties is in WGS84, not in same datum as l1G1G2
plot(l1G1G2, add=TRUE)
plot(l1G1G2[grep( "Astragalus",l1G1G2$GNAME),], border = "red", add=TRUE)
plot(l1G1G2[grep( "Penstemon",l1G1G2$GNAME),], border = "blue", add=TRUE)


```
       [1] WGS84                     WGS 84                    WGS 1984                      
       [4] WGS96                     WGS 72                    WGS-84                     
       [7] WGS 1984.                 WGS83                     WGS84 (UTM Datum: NAD83)   
      [10] WGS84  (UTM Datum: NAD83) WGS84, Google Earth       WGS 1983                   
      [13] WGS 1984,                 WGS98                     WGS85                       
      [16] WGS86                     WGS89                     WGS95                       
      [19] WGS87                     WGS88                     WGS97                       
      [22] WGS92                     WGS 83                    WGS93                       
      [25] WGS94                     WGS84/NAD83               WGS90                        
      [28] WGS 19                    WGS99                     WGS91      
      
      "The latest revision is WGS 84 (also known as WGS 1984, EPSG:4326), established in 1984 and last revised in 2004.[1] Earlier schemes included WGS 72, WGS 66, and WGS 60. WGS 84 is the reference coordinate system used by the Global Positioning System."

Scale bar attempts
```{r}
myScalebar = function(units_label, yadj=1.5) {

  # Get plot coordinates
  pc = par("usr") 

  # Position scale line between last two major x-axis tick marks
  # and 1/10th of the total y-range above the lower y-axis coordinate
  lines(c(floor(pc[2]-100),floor(pc[2])),     
        rep(pc[3] + 0.1*(pc[4] - pc[3]), 2))

  # Place the units label at the midpoint of and just below the scale line
  text(x=mean(c(floor(pc[2]-100), floor(pc[2]))), 
       y=pc[3] + 0.1*(pc[4] - pc[3]),
       label=units_label, adj=c(0.5, yadj))
}

ScaleBar <- function(reference_raster_utm, round_to_nearest_km, width_percent, y_percent_from_bottom, x_percent_from_left, y_text_percent_from_bottom, ...) {
    # Round by max to nearest... e.g. 5 km 
    mround <- function(x,base){ 
        base*round(x/base) 
    }   
    # scale bar size adjustment to avoid decimals
        scale_size <- ((xmax(reference_raster_utm)-xmin(reference_raster_utm))*width_percent)/1000
        scale_size_adj <- mround(scale_size, round_to_nearest_km)
        scale_size_adj_plot <- (scale_size_adj*1000)/2
    # Horizontal percent position (x) for scale bar
        x_position <- ((xmax(reference_raster_utm)-xmin(reference_raster_utm))*x_percent_from_left)+xmin(reference_raster_utm)
    # Vertical percent position y for scale bar
        y_position <- ((ymax(reference_raster_utm)-ymin(reference_raster_utm))*y_percent_from_bottom)+ymin(reference_raster_utm)
        y_position_text <- ((ymax(reference_raster_utm)-ymin(reference_raster_utm))*y_text_percent_from_bottom)+ymin(reference_raster_utm)
    # Draw line on plot
        library(sp)
        x_ends <- c((x_position-scale_size_adj_plot), (x_position+scale_size_adj_plot))
        y_ends <- c((y_position), (y_position))
        scale_bar_line <- SpatialLines(list(Lines(Line(cbind(x_ends, y_ends)), ID="length")))
        projection(scale_bar_line) <- projection(reference_raster_utm)
        plot(scale_bar_line, add=TRUE, ...)
        text(x_position, y_position_text, paste0(scale_size_adj, "km"))
}

```

#map each species, map each EOR, check distance from points to nearest EORs
```{r}
#l1G1G2 are in UTM zone 13
#l1G1G2@proj4string <- CRS("+proj=utm +zone=13 ellps=NAD83") 
# says  projargs: chr "+proj=utm +zone=13 ellps=NAD83 +ellps=WGS84
#transform to UTM to match l1G1G2
#60 names with the listed name and the accepted name acording to TPL

coloradosps.dist <- coloradosps.g1g2
coloradosps.dist$distNearEOR <- NA

distXsp <- lapply(1:nrow(g1g2names), function(i){
  g1g2now <- coloradosps.g1g2[coloradosps.g1g2$scientificName %in%
                                c(g1g2names$Taxon[i],g1g2names$AcceptedName[i]),]
  
  areanow <- sapply(slot(l1G1G2[l1G1G2$GNAME %in% c(g1g2names$AcceptedName[i],
                                         g1g2names$Taxon[i]),], "polygons"), 
         slot, "area")

  g1g2now$decimalLatitude <- as.numeric(as.character(g1g2now$decimalLatitude))
  g1g2now$decimalLongitude <- as.numeric(as.character(g1g2now$decimalLongitude))
  g1g2now <- g1g2now[!is.na(g1g2now$decimalLatitude),]
  g1g2now <- g1g2now[!is.na(g1g2now$decimalLongitude),]
  if(nrow(g1g2now)>0){
    #turn into spatialpointsdataframe for individual species
    coordinates(g1g2now) <- ~decimalLongitude+decimalLatitude
    proj4string(g1g2now) <- CRS("+proj=longlat +datum=WGS84") 
    g1g2now <- spTransform(g1g2now, CRS("+proj=utm +zone=13 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"))
    distnow <- apply(gDistance(g1g2now,
                               l1G1G2[l1G1G2$GNAME %in% c(g1g2names$AcceptedName[i],
                                                          g1g2names$Taxon[i]),], byid=TRUE),
                     2,min)
    out <- list(g1g2now, distnow, areanow)
  } else {
      out <- list(NA,NA)
    }
  out
  })

distXspbind <- do.call(c,mapply('[[', distXsp, 2))
 
length(distXspbind[is.na(distXspbind)]) #14 don't have any data
distXspbind <- distXspbind[!is.na(distXspbind)]
coloradosps.dist$distNearEOR[which(rownames(coloradosps.dist) %in%
                                         names(distXspbind))] <-unname(distXspbind)
  

```

```{r}

plot(distNearEOR~as.factor(scientificName), coloradosps.dist[coloradosps.dist$distNearEOR<500000,], las=2)

nrow(coloradosps.dist) #2451
colo.merged <- merge(coloradosps.dist, g1g2names, by.x = "scientificName", by.y="AcceptedName")
nrow(colo.merged) #2251
colo.merged.taxon <- merge(coloradosps.dist, g1g2names, by.x = "scientificName", by.y="Taxon")
nrow(colo.merged.taxon) #2121
## Want the ones that are only in the first and only the second and one copy of the middle ones... 
colo.all <- unique(rbind(colo.merged[,-grep("^Taxon$", names(colo.merged))], 
                         colo.merged.taxon[,-grep("^AcceptedName$",names(colo.merged.taxon))]))
nrow(colo.all) #2451
#Names that aren't in TPL
unique(colo.all$scientificName[colo.all$Family==""]) #"Gutierrezia elegans"
colo.all$Family[colo.all$Family==""] <- "Asteraceae"

par(mai=c(7,3,.1,.1))
plot(distNearEOR~as.factor(Family), colo.all[colo.all$distNearEOR<500000,], las=2,
     xlab="",ylab="")

length(table(colo.merged$Taxon)) #58 species with some data
```

Code to figure out how to iterate over all 60 species for which I have EOR data from CNHP
```{r, eval=FALSE}
g1g2now <- coloradosps.g1g2[coloradosps.g1g2$scientificName %in% c(g1g2names$Taxon[7],
                                                                   g1g2names$AcceptedName[7]),]
nrow(g1g2now)

g1g2now$decimalLatitude <- as.numeric(as.character(g1g2now$decimalLatitude))
g1g2now <- g1g2now[!is.na(g1g2now$decimalLatitude),]
nrow(g1g2now)
g1g2now$decimalLongitude <- as.numeric(as.character(g1g2now$decimalLongitude))


coordinates(g1g2now) <- ~decimalLongitude+decimalLatitude
proj4string(g1g2now) <- CRS("+proj=longlat +datum=WGS84") #should go line by line and change randomly to see effect of different projections since don't know for sure. 
 #next define random, or based on reported, would have to sample rows randomly and assign or group by reported and assign and then transform and rbind(spdf1,spdf2), might need to spChFIDs(spdf2, paste("name", row.names(spdf2), sep="."))

unique(coloradosps.g1g2$geodeticDatum)
sim.proj4string <- c(CRS("+init=epsg:4326"), #WGS84
                     CRS("+init=epsg:4269"), #NAD83 but without zone?!
                     CRS("+init=epsg:4267"), #NAD27 but without zone?!
                     CRS("+proj=utm +zone=13 +datum=NAD83"),
                     CRS("+proj=utm +zone=13 +datum=NAD27")) 


sample(sim.proj4string,20, replace=TRUE)

g1g2now <- spTransform(g1g2now, CRS("+proj=utm +zone=13 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"))

distnow <- apply(gDistance(g1g2now,
          l1G1G2[l1G1G2$GNAME %in% c(g1g2names$AcceptedName[1],g1g2names$Taxon[1]),], byid=TRUE),
          2,min)

#Row Names!
unique(coloradosps.g1g2$scientificName[which(rownames(coloradosps.g1g2) %in% names(distnow))])
foo <- coloradosps.g1g2
foo$distNearEOR <- NA
length(foo$distNearEOR[which(rownames(coloradosps.g1g2) %in% names(distnow))]) #120, that's right
#Oh, row names, not row numbers, row numbers from coloradosps, but kept row numbers to coloradosps.g1g2
foo$distNearEOR[which(rownames(foo) %in% names(distnow))] <-unname(distnow)

length(g1g2now)
hist(as.numeric(distnow)/1000, main = "Distance (km) from points to nearest EOR")
```

#Animate maps over each species with points and polygons
```{r}
all.g1g2now <- do.call(c,mapply('[[', distXsp, 1)) #all the transformed to UTM species points
all.g1g2now <- all.g1g2now[!is.na(all.g1g2now)]
all.g1g2now.joined <- lapply(all.g1g2now, function(x) {
  out <- x@coords
  out[,3] <- })
g1g2.stack <- stack(all.g1g2now) #or could it be points? needs to be a raster
g1g2.df <- as.data.frame(g1g2.stack)

ggplot()

plot(colocounties.UTM, border="grey80")
plot(l1G1G2[l1G1G2$GNAME %in% c(g1g2names$AcceptedName[1],g1g2names$Taxon[1]),],
     border = "red", add=TRUE, lwd=4)
points(distXsp[[1]][[1]], pch=16, cex=0.25)
#scalebar(1000, xy = c(extent(raster(colocounties.UTM))[c(2,4)]-100000), type = "bar", divs = 4, 
#         below = "km", lwd = 2) #label = c(0,50,100),adj=c(0.5, -0.5),lonlat = NULL, 
#myScalebar("1 km")
ScaleBar(raster(colocounties.UTM), 100, .20, .10, .75, .07, lwd=2)
```


```{r}

#distXsp[[i]][[1]] are the herbarium points
speciesNoHerb <- do.call(c,mapply('[[', distXsp, 1))
want <- which(do.call(c,lapply(speciesNoHerb, function(x) !is.na(x))))

l1G1G2@bbox[l1G1G2$GNAME %in%
                           c(g1g2names$AcceptedName[i],g1g2names$Taxon[i])]

l1G1G2@polygons[[1]]@Polygons[[1]]@coords


l1G1G2@polygons[[l1G1G2$GNAME %in%
                           c(g1g2names$AcceptedName[i],g1g2names$Taxon[i])]]@Polygons[[1]]@coords
```


```{r}
for(i in want){
  plot(l1G1G2[l1G1G2$GNAME %in% c(g1g2names$AcceptedName[i],g1g2names$Taxon[i]),],
       border = rgb(1,0,0,0.5),  main=g1g2names$AcceptedName[i], lwd=3,
       xlim=c(min(distXsp[[i]][[1]]@coords[,1]),max(distXsp[[i]][[1]]@coords[,1])),
       ylim=c(min(distXsp[[i]][[1]]@coords[,2]),max(distXsp[[i]][[1]]@coords[,2])))
  points(distXsp[[i]][[1]], pch=16, cex=0.5, col=rgb(0,0,0,0.75))
  ScaleBar(raster(l1G1G2[l1G1G2$GNAME %in%
                           c(g1g2names$AcceptedName[i],g1g2names$Taxon[i]),]), 
           1, .20, .90, .15, .87, lwd=2)
}

```

```{r}
for(i in 1:nrow(g1g2names)){
  plot(colocounties.UTM, border="grey80", main=g1g2names$AcceptedName[i])
  plot(l1G1G2[l1G1G2$GNAME %in% c(g1g2names$AcceptedName[i],g1g2names$Taxon[i]),],
       border = rgb(1,0,0,0.5), add=TRUE, lwd=10)
  points(distXsp[[i]][[1]], pch=16, cex=0.5, col=rgb(0,0,0,0.75))
  ScaleBar(raster(colocounties.UTM), 100, .20, .10, .75, .07, lwd=2)
}

```

4/6/2018 - Danielle Gualtieri working on Colton Gaines protocol for mapping and adding uncertainty protocol (similar to Mo's work)


#Mechanistic models based on matrix models growth rates and fecundity correlative, use some model selection? for best prediction by species  
```{r}
load("Q:/Research/Stats & Software/COMPADRE_PlantMAtrixDatabase/COMPADRE_v.4.0.1.RData")



```



# How do the maping techniques change by time, herbarium, or collector (amount of informaiton given)?   
#Some data cleaning of colo.all, use colo.test first
```{r}
i <- sapply(colo.all, is.factor)
colo.all[i]<-lapply(colo.all[i], as.character)

colo.all$year <- as.numeric(colo.all$year)
colo.all$decimalLatitude <- as.numeric(colo.all$decimalLatitude)
colo.all$decimalLongitude <- as.numeric(colo.all$decimalLongitude)
colo.all$minimumElevationInMeters <- as.numeric(colo.all$minimumElevationInMeters)

colo.all[colo.all$recordNumber == 9088,] #year is 1999, not recorded at Fort Lewis
colo.all[colo.all$recordNumber == 1596,] #another repeat, should be 1997 not 1007
## Ok to get rid of duplicates that resulted in wrong years
colo.all <- colo.all[colo.all$year > 1800,]

colo.all$coordinateUncertaintyInMeters <-
  as.numeric(colo.all$coordinateUncertaintyInMeters)
#How many specimens give an uncertainty in meters (square meters?)
length(colo.all$coordinateUncertaintyInMeters[!is.na(colo.all$coordinateUncertaintyInMeters) & !is.na(colo.all$decimalLatitude)])/
  length(colo.all$coordinateUncertaintyInMeters[!is.na(colo.all$decimalLatitude)])

colo.all[is.na(colo.all$coordinateUncertaintyInMeters),]

colo.all[colo.all$distNearEOR>50000 & !is.na(colo.all$distNearEOR),c(56,57,83,61,63,66,67)] #611551meters is width of colorado about

#Can't have missing data
colo.all.ll <- colo.all[!is.na(colo.all$decimalLatitude)&
                       !is.na(colo.all$decimalLongitude),]
coordinates(colo.all.ll) <-~decimalLongitude+decimalLatitude
proj4string(colo.all.ll) <- CRS("+proj=longlat +datum=WGS84") 
colo.all.ll <- spTransform(colo.all.ll, CRS("+proj=utm +zone=13 +datum=NAD83 +units=m +no_defs +ellps=GRS80 +towgs84=0,0,0"))

all.county <- over(colo.all.ll, colocounties.UTM[,"COUNTY"])
colo.all.ll$InCounty <- all.county[,1]


table(colo.all.ll$county[colo.all.ll$county != colo.all.ll$InCounty])
colo.all.ll@data[colo.all.ll$county != colo.all.ll$InCounty &
              !is.na(colo.all.ll$county),c("scientificName","institutionCode","county","InCounty","georeferencedBy")]

#Which county are the points really in
colocounties.UTM.df <- as.data.frame(colocounties.UTM)
colocounties.UTM.df$id <- as.numeric(rownames(colocounties.UTM.df))

plot(colocounties.UTM, border="grey80")
plot(colo.all.ll, add=TRUE, pch=16, cex=0.5)

#Make a Levenshtein distance matric between names (like that paper!)
countymatch<- adist(colo.all.ll@data$county[!is.na(colo.all.ll@data$county)&
                                              colo.all.ll@data$county!=""],
                    colo.all.ll@data$InCounty[!is.na(colo.all.ll@data$county)&
                                              colo.all.ll@data$county!=""],
                    partial=TRUE,ignore.case = TRUE)
#Single linkage method
hcfar <- hclust(as.dist(countymatch), method='single')


#errors so try clean up county column
colo.all.ll$countyclean <- gsub("Co.*","",colo.all.ll$county)
#trim trailing white space
colo.all.ll$countyclean <- sub("\\s+$", "", colo.all.ll$countyclean)
colo.all.ll$countyclean <- toupper(colo.all.ll$countyclean)

colo.all.ll@data[!(colo.all.ll$countyclean %in%colo.all.ll$InCounty),]

nrow(colo.all.ll@data[!(colo.all.ll$countyclean %in%colo.all.ll$InCounty),])/
       nrow(colo.all.ll)

colo.all.ll@data[!(colo.all.ll$countyclean %in%colo.all.ll$InCounty),]

```


Assuming CNHP is nearly correct 
```{r}
colo.all[colo.all$recordNumber%in%
           colo.all.ll@data$recordNumber[colo.all.ll$distNearEOR>5000000],
         c("decimalLatitude","decimalLongitude","county","verbatimCoordinates",
           "habitat","locality")] ##Location would be correct but decimalLongitude goes to -160.4; The easting has an extra zero: -105.7131, 38.1374; 3972 m

colo.all$locality

ggplot(colo.all.ll@data[colo.all.ll$distNearEOR<5000000,], aes(year, distNearEOR/1000))+
  geom_point()+
  theme_bw()+
  ylab("Distance (km) to nearest EOR")

```



```{r}
#install.packages("biogeo")
library(biogeo)

?biogeo

#Elevation check based on digital elevation model
data("dem")

biogeocolo.all.ll <- data.frame(colo.all.ll,ID=NA, 
                                x=NA, y=NA, Species=NA, 
                                x_original=NA, y_original=NA, 
                                Correction=NA, Modified=NA, Reason=NA, Exclude=NA )
elevcheck1 <- elevcheck(biogeocolo.all.ll, 
                        dem=raster(dem,xmn=-109, xmx=103, ymn=37, ymx=41),
                                   elevc = "minimumElevationInMeters",
                                   50)


```

Choroplethr from Jessie's code
```{r}
library(devtools)
install_github("choroplethr", "trulia")
 
library(choroplethr)

```

#This will just make each state different color, But I want the thing that makes points bigger when closer together. 
```{r}
tab <- table(colo.all.ll$InCounty)
choro.in<- data.frame(region = names(tab), value = tab  )
choro.in$value.Var1 <- NULL 
choro.in$value <- choro.in$value.Freq
choro.in$value.Freq <- NULL
choro.in$region <- sapply(choro.in$region, function(x) {tolower(x)})

state_choropleth(choro.in)#
ggsave(filename="Q:/Research/Presentations/External Conference presentations/Natural Areas Conference 2018/NAC_DePrenger-Levin_BDAversion.pptx/HerbPoints.pdf")

```

#how many are in the county they say they should be in? Check Jessie's code for help
```{r}
ggplot(colo.all[colo.all$distNearEOR<50000,], aes(as.numeric(year), distNearEOR))+
  geom_point()+
  stat_smooth(se=FALSE)+
  theme_bw()+
  xlab("Year")+
  ylab("Distance from nearest EOR")+
#  labs(color='Georeference Method')+
   theme(axis.text.x = element_text(angle = 90, hjust = 1)) 
```


```{r}
ggplot(colo.test[eors$Year.2>0,], aes( Year.2,NEAR_DIST,colour=institutio))+
  geom_point()+
  facet_wrap(~institutio)+
  theme_bw()+
  stat_smooth(method="lm", se=FALSE)

ggplot(eors[eors$Year.2>0,], aes( Year.2,NEAR_DIST))+
  geom_point()+
  theme_bw()+
  stat_smooth(method="lm", se=FALSE)

summary(lm(NEAR_DIST~Year.2, data=eors[eors$Year.2>0,]))
```

How did the type of mapping method change over time?
```{r}

table(eors$Year.2)



```

Which method has the shortest distance?   
```{r}


ggplot(eors2, aes(x=Map.Method))+
  geom_bar(aes(fill=institutio))


ggplot(eors2, aes(Year.2,NEAR_DIST, colour=institutio))+
  geom_point()+
  theme_bw()

ggplot(eors2, aes(x=Year.2, fill=Map.Method))+
  geom_density(alpha=0.5)+
  theme_bw()
#+  facet_wrap(~Map.Method)

ggplot(eors2, aes(x=Year.2, fill=Map.Method))+
  geom_histogram(alpha=0.25)+
  theme_bw()


```

Maybe regional collections are much better?   
FLD = Fort Lewis College    
DES = Dessert Arizona   
MESA = Colorado Mesa University   
MISSA = Miss State Univ   
NMC = New Mexico State University    
SJNM = San Juan College, New Mexico   
UCR = University of California Riverside    
USUUB = Utah STate University Uintah Basin (probably is USU)   
UVSC = Utah Valley University	U.S.A. Utah. Orem.      
```{r}

local <- c("COLO","CS","DBG","FLD","MESA","RM","RMBL")
Adjacent <- c("ASC","ASU","BRY","DES","NMC","RM","SJNM","UNM","USUUB","UVSC")
far <- c("CM","F","MISSA","MO","NY","RENO","UCR")

eors2$InstNear[eors2$institutio %in% local] <- "Local"
eors2$InstNear[eors2$institutio %in% Adjacent] <- "Near"
eors2$InstNear[eors2$institutio %in% far] <- "Far"

eors2$InstNear <- factor(eors2$InstNear, levels = c("Far","Near","Local"))


ggplot(eors, aes(x=institutio))+
  geom_bar(aes(fill=Map.Method))


ggplot(eors2, aes(x=InstNear))+
  geom_bar(aes(fill=Map.Method))

ggplot(eors2, aes(Year.2,NEAR_DIST, colour=InstNear))+
  geom_point()+
  theme_bw()+
  stat_smooth(method="lm", se=FALSE)


ggplot(eors2, aes(NEAR_DIST))+
  geom_density(aes(fill=InstNear))
```

Would assume that Locality method would be best for local institutions, worse for far
```{r}


ggplot(eors2, aes(Map.Method, NEAR_DIST, colour=Map.Method))+
  geom_boxplot()+
  facet_wrap(~InstNear)+
  theme_bw()+
  xlab("Mapping method")+
  ylab("Distance to closest mapped occurence")
```

Assuming CNHP has accurate and complete data, then Distance to a known mapped location 
```{r}
table(eors2$Map.Method, eors2$InstNear)

length(table(eors2$scientific)) #53

#species are the names collected from SEINet
match(sort(unique(eors2$scientific)),sort(species))

InEOR <- do.call(rbind,lapply(split(eors2, eors2$scientific), function(x){
  out <- x[x$NEAR_DIST ==0,]
  out
})
)

head(InEOR)
table(InEOR$recordedBy)

# $georeferen is the only place to know who did the georeferencing, that would be very helpful to know
```


The Weber example of an out of state person mapping a collection to Gray's Peak from Chicago Lake that should be Mount Evans.     
- <https://conps.org/wp-content/uploads/2015/05/Mount_Evans_Summit_Lake_4-24-2011.pdf>    
```{r}


```


"coloradosps" == SEINet collections from Colorado - downloaded 12/6/2017 from SEINet      
"coloG1G2" == species matching names in L1 EORs but without any synonym corrections     
"seinet" == Mo worked on this, made distances from nearest EOR and looked at posted informaiton to figure out what might have been used to pick point on map        
      
ITISlist is synonmy pulled from ITIS into SQL    
TPL is pulling from synonym from the plant list   "colo"   
      "seinetMo"is synonymy with TPL for Mo's list of 53 species (that are G1/G2s)   
      "colonames" is synonym with TPL for all colorado specimens from SEINet   
```{r}
ITISlist <- read.csv("C:/Users/deprengm/Dropbox/Biological Collections_concerns&needs/ITIS_sqlsynonyms.csv")
length(unique(ITISlist$tsn[ITISlist$tsn != "NULL"])) #2528 are synonyms
length(unique(ITISlist$tsn_accepted[ITISlist$tsn_accepted != "NULL"])) #2277, 251 combined with synonmy
nrow(ITISlist[ITISlist$tsn != "NULL",]) #2530 are not synonyms 
nrow(ITISlist) #22570, huh. 

head(ITISlist[ITISlist$tsn != "NULL",])
ITISlist[ITISlist$tsn.1 == 897847,] #Want Equisetum giganteum
#Probably could have done this in SQL for the download.....
ITISsynonyms <- merge(ITISlist[,c("tsn","tsn_accepted","unit_name1","unit_name2")], 
                   ITISlist[,c("tsn.1","unit_name1","unit_name2")], by.x = "tsn_accepted", by.y = "tsn.1")

ITISsynonyms[ITISsynonyms$tsn_accepted == 897847,]
length(unique(ITISsynonyms$tsn_accepted)) #1777 --hummm... So these are the number of taxa (the accepted names) from ones that have some synonomy. There are still others that are just accepted. 
head(ITISsynonyms)

ITIScoloradosps <- coloradosps
ITIScoloradosps$genus
```




